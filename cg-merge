#!/usr/bin/env bash
#
# Merge a branch to the current tree.
# Copyright (c) Petr Baudis, 2005
#
# Takes a parameter identifying the branch to be merged, defaulting
# to 'origin'.
#
# This command merges all changes currently in the given branch to your
# current branch. This can produce a merging commit on your branch sticking
# the two branch together (so-called 'tree merge'). However in case there
# are no changes in your branch that wouldn't be in the remote branch, no
# merge commit is done and commit pointer of your branch is just updated
# to the last commit on the remote branch (so-called 'fast-forward merge').
#
# In case of conflicts being generated by the merge, you have to examine
# the tree (cg-merge will tell you which files contain commits; the commits
# are denoted by rcsmerge-like markers <<<<, ====, and >>>>) and then do
# `cg-commit` yourself. `cg-commit` will know that you are committing a merge
# and will record it properly.
#
# Note that when you are merging remote branches, `cg-merge` will use them
# in the state they are currently at in your repository. If you want to
# fetch the latest changes from the remote repository, use `cg-fetch`. If you
# want to fetch the changes and then merge them to your branch, use the command
# `cg-update`.
#
# Also note that if you have local changes in your tree that you did not
# commit, cg-merge will always preserve them when fast-forwarding. When doing
# a tree merge, it will preserve them if they don't conflict with the merged
# changes, and report an error otherwise. In short, it should do the Right
# Thing (tm), never lose your local changes and never let them mix up with
# the merge.
#
# OPTIONS
# -------
# -b BASE_COMMIT::
#	Parameter specifies the base commit for the merge. Otherwise, the
#	least common ancestor is automatically selected.
#
# -c::
#	Parameter specifies that you want to have tree merge never
#	autocommitted, but want to review and commit it manually. This will
#	basically make cg-merge always behave like there were conflicts
#	during the merge.
#
# FILES
# -----
# $GIT_DIR/hooks/merge-pre::
#	If the file exists and is executable it will be executed right
#	before the merge itself happens. The script is passed those
#	arguments:
#		BRANCHNAME BASE CURHEAD MERGEDHEAD MERGETYPE
#	MERGETYPE is either "forward" or "tree". The merge is
#	cancelled if the script returns non-zero exit code.
#
# $GIT_DIR/hooks/merge-post::
#	If the file exists and is executable it will be executed after
#	the merge is done. The script is passed those arguments:
#		BRANCHNAME BASE CURHEAD MERGEDHEAD MERGETYPE STATUS
#	MERGETYPE is either "forward" or "tree". For "forward", the
#	STATUS is always "ok", while for "tree" the STATUS can be
#	"localchanges", "conflicts", "nocommit", or "ok".

USAGE="cg-merge [-c] [-b BASE_COMMIT] [BRANCH_NAME]"
_git_requires_root=1

. ${COGITO_LIB}cg-Xlib || exit 1


prehook()
{
	if [ -x $_git/hooks/merge-pre ]; then
		$_git/hooks/merge-pre "$branchname" "$base" "$head" "$branch" "$@" || die "merge cancelled by hook"
	fi
}

posthook()
{
	if [ -x $_git/hooks/merge-post ]; then
		$_git/hooks/merge-post "$branchname" "$base" "$head" "$branch" "$@"
	fi
}


head=$(cg-object-id -c) || exit 1


careful=
base=
while optparse; do
	if optparse -c; then
		careful=1
	elif optparse -b=; then
		base=$(cg-object-id -c "$OPTARG") || exit 1
	else
		optfail
	fi
done

branchname="${ARGS[0]}"
[ "$branchname" ] || { [ -s $_git/branches/origin ] && branchname=origin; }
[ "$branchname" ] || die "what to merge?"
branch=$(cg-object-id -c "$branchname") || exit 1

[ "$base" ] || base=$(git-merge-base "$head" "$branch")
[ "$base" ] || die "unable to automatically determine merge base"


[ -s $_git/blocked ] && die "merge blocked: $(cat $_git/blocked)"

if [ -s "$_git/merging" ] && grep -q "$branch" $_git/merging; then
	echo "Branch already merged in the working tree." >&2
	echo 0
fi

if [ "$base" = "$branch" ]; then
	echo "Branch already fully merged." >&2
	exit 0
fi

if [ "$head" = "$base" ]; then
	# No need to do explicit merge with a merge commit; just bring
	# the HEAD forward.

	echo "Fast-forwarding $base -> $branch" >&2
	echo -e "\ton top of $head..." >&2

	prehook forward
	tree_timewarp "forward" "yes, rollback (or rather rollforth) the tree!" $base $branch
	posthook forward ok

	exit 0
fi


[ "$(git-diff-files -s)" ] && git-update-index --refresh >/dev/null

echo "Merging $base -> $branch" >&2
echo -e "\tto $head..." >&2


prehook tree

git-diff-index --name-only "$(cg-object-id -t $head)" >>"$_git/commit-ignore"
# Don't keep around useless empty files
[ -s "$_git/commit-ignore" ] || rm "$_git/commit-ignore"

if ! git-read-tree -u -m "$(cg-object-id -t $base)" "$(cg-object-id -t $head)" "$(cg-object-id -t $branch)"; then
	echo "cg-merge: git-read-tree failed (merge likely blocked by local changes)" >&2
	posthook tree localchanges
	exit 1
fi

echo $base >>$_git/merge-base
echo $branch >>$_git/merging
echo $branchname >>$_git/merging-sym

if ! git-merge-index -o -q ${COGITO_LIB}cg-Xmergefile -a || [ "$careful" ]; then
	# "Resolve" merges still in the cache (conflicts).
	# We will resolve only those caught by merge-cache;
	# that is "three-way conflicts". Others should still
	# be resolved manually on the lower level by the user.
	git-ls-files --unmerged | {
		stage1mode=
		stage1hash=
		stage1name=
		stage2seen=
		while read -r mode sha1 stage filename; do
			case $stage in
			1)
				stage1mode="$mode"
				stage1hash="$sha1"
				stage1name="$filename"
				continue
				;;
			2)
				stage2seen=
				[ "$stage1name" = "$filename" ] && stage2seen=1
				continue
				;;
			3)
				[ "$stage1name" = "$filename" ] || continue
				[ "$stage2seen" ] || continue
				stage2seen=
			esac
			git-update-index --cacheinfo $stage1mode $stage1hash $stage1name
		done
	}

	[ ! "$careful" ] && cat >&2 <<__END__

	Conflicts during merge. Do cg-commit after resolving them.
__END__
	if [ -s "$_git/commit-ignore" ]; then
		echo "	These files contained local modifications and won't be automatically chosen for committing:" >&2
		cat "$_git/commit-ignore" >&2
	fi
	posthook tree conflicts
	exit 2
fi

echo
readtree=
if ! cg-commit -C; then
	readtree=1
	echo "cg-merge: COMMIT FAILED, retry manually" >&2
	posthook tree nocommit
fi

[ "$readtree" ] && git-read-tree -m HEAD
# update_index here is safe because no tree<->index desyncs could've
# survived the read-tree above
update_index

posthook tree ok
