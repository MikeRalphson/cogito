#!/usr/bin/env bash
#
# Show status of your working tree.
# Copyright (c) Petr Baudis, 2005
# Copyright (c) Pavel Roskin 2005
#
# The output includes the list of branches and merge status.
# Current branch is marked by ">".
#
# Then, the files in the working tree are printed out. The output has
# the following format:
#
#	<status flag> <file>
#
# where '<status flag>' can be one of the following:
#
# ?::
#	'<file>' is unknown.
# A::
#	'<file>' has been added.
# D::
#	'<file>' has been deleted.
# M::
#	'<file>' has been touched or modified.
#
# OPTIONS
# -------
# If neither -g or -w is passed, both is shown; otherwise, only the
# corresponding parts are shown.
#
# -g::
#	Show the GIT repository information.
#
# -w::
#	Show the working tree file list.
#
# -x::
#	Don't exclude any files from listing.
#
# FILES
# -----
# $GIT_DIR/info/exclude::
#	If the file exists it will be used to prune which files to
#	show status for. The format is similar to the `dontdiff` file;
#	each line contains a pattern for a file or group of files
#	to exclude.
#
# $TREE_DIR/.gitignore::
#	.gitignore in the working tree will be used as an exclude file.
#	The excludes are applied from the project root approaching the
#	current subdirectory.

USAGE="cg-status [-g] [-w] [-x]"

. ${COGITO_LIB}cg-Xlib || exit 1

gitstatus=
workstatus=
noexclude=
while optparse; do
	if optparse -g; then
		gitstatus=1
	elif optparse -w; then
		workstatus=1
	elif optparse -x; then
		noexclude=1
	else
		optfail
	fi
done
if [ ! "$gitstatus" ] && [ ! "$workstatus" ]; then
	gitstatus=1
	workstatus=1
fi



if [ "$gitstatus" ]; then
	mkdir -p $_git/refs/heads
	[ "$(find $_git/refs/heads -follow -type f)" ] \
	       || die "List of heads is empty."


	[ -s "$_git/branch-name" ] && echo "Branch (informal): $(cat "$_git/branch-name")"

	if [ -s "$_git/head-name" ]; then
		headsha1=$(cat $_git/HEAD)
		echo "Seeked from head: $(cat "$_git/head-name")"
		echo "Seeked at commit: $headsha1"
		echo
	fi

	echo "Heads:"
	for head in $_git/refs/heads/*; do
		headsha1=$(cat $head)
		headname=$(basename $head)
		[ "$headname" = "cg-seek-point" ] && continue
		if [ "$headname" = "$_git_head" ]; then
			echo -e "   >$headname\t$headsha1"
		else
			echo -e "    $headname\t$headsha1"
		fi
	done

	if [ -s "$_git/merging" ]; then
		tmp=$(cat "$_git/merging")
		echo
		echo "Merging: $(cat "$_git/merging") ($(cat "$_git/merging-sym"))"
		echo "Merge base: $(cat "$_git/merge-base")"
	fi

	if [ -s "$_git/blocked" ]; then
		echo
		echo "Changes recording BLOCKED:"
		sed 's/^/    /' "$_git/blocked"
	fi
fi



if [ "$gitstatus" ] && [ "$workstatus" ]; then
	echo
fi



if [ "$workstatus" ]; then
	EXCLUDE=
	if ! [ "$noexclude" ]; then
		for excl in '*.[ao]' '.*' tags '*~' '#*' ',,merge*'; do
			EXCLUDE="$EXCLUDE --exclude=$excl"
		done
		EXCLUDEFILE=$_git/info/exclude
		if [ -f $EXCLUDEFILE ]; then
			EXCLUDE="$EXCLUDE --exclude-from=$EXCLUDEFILE"
		fi
		# This is just for compatibility (2005-09-16).
		# To be removed later.
		EXCLUDEFILE=$_git/exclude
		if [ -f $EXCLUDEFILE ]; then
			echo Warning: .git/exclude is obsolete, use .git/info/exclude instead. >&2
			EXCLUDE="$EXCLUDE --exclude-from=$EXCLUDEFILE"
		fi
		EXCLUDE="$EXCLUDE --exclude-per-directory=.gitignore"
	fi

	git-update-cache --refresh > /dev/null

	git-ls-files --others $EXCLUDE |
		{ if [ "$_git_relpath" ]; then sed -n "s|^$_git_relpath||p"; else cat; fi } |
		sed 's,^,? ,'

	git-diff-cache HEAD $_git_relpath | cut -f5- -d' ' | 
	while IFS=$'\t' read -r mode file; do
		if [ "$mode" = D ]; then
			[ "$(git-diff-files "$file")" ] && mode=!
		fi
		[ "$_git_relpath" ] && file="${file#$_git_relpath}"
		echo "$mode $file"
	done
fi
