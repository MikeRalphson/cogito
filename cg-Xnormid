#!/usr/bin/env bash
#
# Normalize an ID to an SHA1 hash value
#
# Copyright (c) Petr Baudis, 2005
# Copyright (c) Philip Pokorny, 2005
#
# Strings resolve in this order:
# 	NULL, this, HEAD  => .git/HEAD
# 	<tags>
# 	<heads>
# 	short SHA1 (4 or more hex digits)
#
# Takes the ID to normalize and returns the normalized ID.

id="$1"

if [ ! "$id" ] || [ "$id" = "this" ] || [ "$id" = "HEAD" ]; then
	read id < .git/HEAD

elif [ -r ".git/refs/tags/$id" ]; then
	read id < ".git/refs/tags/$id"

elif [ -r ".git/refs/heads/$id" ]; then
	read id < ".git/refs/heads/$id"

# Short id's must be lower case and at least 4 digits.
elif [[ "$id" == [0-9a-z][0-9a-z][0-9a-z][0-9a-z]* ]]; then
	idpref=${id:0:2}
	idpost=${id:2}

	# Assign array elements to matching names
	idmatch=(.git/objects/$idpref/$idpost*)

	if [ ${#idmatch[*]} -eq 1 ] && [ -r "$idmatch" ]; then
		id=$idpref${idmatch#.git/objects/$idpref/}
	elif [ ${#idmatch[*]} -gt 1 ]; then
		echo "Ambiguous id: $id" >&2
		exit 1
	fi
fi

# If we don't have a 40-char ID by now, it's an error
if [ ${#id} -ne 40 ] || [ ! -f .git/objects/${id:0:2}/${id:2} ]; then
	echo "Invalid id: $id" >&2
	exit 1
fi

if [ "$(git-cat-file -t "$id")" = "tag" ]; then
	id=$(git-cat-file tag "$id" | head -n 1)
	id="${id#object }"
fi

echo $id
