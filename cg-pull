#!/usr/bin/env bash
#
# Pulls changes from remote branch to the local GIT repository.
# Copyright (c) Petr Baudis, 2005
#
# See cg-branch-add for some description.
#
# Takes the branch' name.

. cg-Xlib

name=$1


[ "$name" ] || die "where to pull from?"
uri=$(cat ".git/branches/$name" 2>/dev/null) || die "unknown branch"

rembranch=master
if echo "$uri" | grep -q '#'; then
	rembranch=$(echo $uri | cut -d '#' -f 2)
	uri=$(echo $uri | cut -d '#' -f 1)
fi


fetch_rsync () {
	redir=
	if [ "$1" = "-i" ]; then # ignore-errors
		redir="2>/dev/null"
		shift
	fi

	filter="cat"
	if [ "$1" = "-s" ]; then # subsequent
		# We already saw the MOTD, thank you very much.
		filter="grep -v ^MOTD:"
		shift
	fi

	rsync_flags_l=
	if [ "$1" = "-u" ]; then # update
		rsync_flags_l="--ignore-existing"
		shift
	fi

	appenduri=
	if [ "$1" = "-d" ]; then # directory
		appenduri="/." # CowboyNeal
		shift
	fi

	eval rsync $RSYNC_FLAGS $rsync_flags_l --whole-file -v -Lr \
		"$1$appenduri" "$2$appenduri" $redir | $filter
	return ${PIPESTATUS[0]}
}

pull_rsync () {
	fetch_rsync -s -u -d "$2/objects" ".git/objects"
}


fetch_http () {
	[ "$1" = "-i" ] && shift
	[ "$1" = "-s" ] && shift

	wget_flags="-nv"

	update=
	if [ "$1" = "-u" ]; then
		wget_flags="$wget_flags -nc"
		update=1
		shift
	fi

	directory=
	if [ "$1" = "-d" ]; then
		wget_flags="$wget_flags -r -l 1 -np -nd -P"
		directory=1
		shift
	else
		wget_flags="$wget_flags -O"
	fi

	src="$1"
	dest="$2"

	[ "$update" ] && ! [ "$directory" ] && [ -e "$dest" ] && return 1

	if echo "$dest" | grep -q '^\.git/'; then
		# wget is idiotic and convers . to _
		dest=$(echo "$dest" | sed 's#^.git/##')
		pushd .git >/dev/null
	else
		pushd . >/dev/null
	fi

	wget $wget_flags "$dest" "$src" 2>&1 | grep -vF 'robots.txt' | grep -vF 'index.html'
	[ -d "$dest" ] && rm -f "$dest"/robots.txt "$dest"/index.html*
	popd >/dev/null
}

pull_http () {
	git-http-pull -a "$(cat ".git/refs/heads/$1")" "$2/"
}


fetch_ssh () {
	[ "$1" = "-i" ] && shift
	[ "$1" = "-s" ] && shift

	scp_flags=

	update=
	if [ "$1" = "-u" ]; then
		update=1
		shift
	fi

	directory=
	if [ "$1" = "-d" ]; then
		scp_flags="$scp_flags -r"
		directory=1
		shift
	fi

	src=$(echo "$1" | sed 's#^git+ssh://\([^/]*\)\(/.*\)$#\1:\2#')
	dest="$2"

	[ "$update" ] && ! [ "$directory" ] && [ -e "$dest" ] && return 1
	[ "$update" ] && [ "$directory" ] &&
		echo "Warning: Unable to protect against overwriting $dest" 2>/dev/null

	echo scp $scp_flags "$dest" "$src"
	scp $scp_flags "$src" "$dest"
}

pull_ssh () {
	git-rpull -a "$(cat ".git/refs/heads/$1")" "$2"
}


fetch_local () {
	[ "$1" = "-i" ] && shift
	[ "$1" = "-s" ] && shift

	cp_flags_l="-va"
	if [ "$1" = "-u" ]; then
		cp_flags_l="$cp_flags_l -lu"
		shift
	fi

	cut_last=
	if [ "$1" = "-d" ]; then
		cut_last=1
		shift
	fi

	src="$1"
	dest="$2"
	[ "$cut_last" ] && dest=${dest%/*}

	cp $cp_flags_l "$src" "$dest"
}

pull_local () {
	git-local-pull -a -l -v "$(cat ".git/refs/heads/$1")" "$2"
}

if echo "$uri" | grep -q "^http://"; then
	fetch=fetch_http
	pull=pull_http
elif echo "$uri" | grep -q "^git+ssh://"; then
	fetch=fetch_ssh
	pull=pull_ssh
elif echo "$uri" | grep -q ":"; then
	fetch=fetch_rsync
	pull=pull_rsync
else
	[ -d $uri/.git ] && uri=$uri/.git
	fetch=fetch_local
	pull=pull_local
fi


orig_head=
[ -s ".git/refs/heads/$name" ] && orig_head=$(cat ".git/refs/heads/$name")


mkdir -p .git/refs/heads
rsyncerr=
$fetch -i "$uri/refs/heads/$rembranch" ".git/refs/heads/$name" || rsyncerr=1
if [ "$rsyncerr" ]; then
	rsyncerr=
	$fetch -s "$uri/heads/$rembranch" ".git/refs/heads/$name" || rsyncerr=1
fi
if [ "$rsyncerr" ] && [ "$rembranch" = "master" ]; then
	rsyncerr=
	$fetch -s "$uri/HEAD" ".git/refs/heads/$name" || rsyncerr=1
fi
[ "$rsyncerr" ] && die "unable to get the head pointer of branch $rembranch"

[ -d .git/objects ] || mkdir -p .git/objects
$pull "$name" "$uri" || die "objects pull failed"

# FIXME: Warn about conflicting tag names?
# XXX: We now throw stderr to /dev/null since not all repositories
# may have tags/ and users were confused by the harmless errors.
[ -d .git/refs/tags ] || mkdir -p .git/refs/tags
rsyncerr=
$fetch -i -s -u -d "$uri/refs/tags" ".git/refs/tags" || rsyncerr=1
if [ "$rsyncerr" ]; then
	rsyncerr=
	$fetch -i -s -u -d "$uri/tags" ".git/refs/tags" || rsyncerr=1
fi
[ "$rsyncerr" ] && echo "unable to get tags list (non-fatal)" >&2


new_head=$(cat ".git/refs/heads/$name")

if [ ! "$orig_head" ]; then
	echo "New branch: $new_head"

elif [ "$orig_head" != "$new_head" ]; then
	echo "Tree change: $orig_head:$new_head"
	git-diff-tree -r $(tree-id $orig_head) $(tree-id $new_head)

else
	echo "Up to date."
	exit
fi
